<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Epoll Game Client - Browser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .game-area {
            flex: 1;
            position: relative;
            background: #0a0a0a;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #444;
        }
        
        .status {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .status.connected {
            border-left: 4px solid #4caf50;
        }
        
        .status.disconnected {
            border-left: 4px solid #f44336;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        button.disconnect {
            background: #f44336;
        }
        
        button.disconnect:hover {
            background: #da190b;
        }
        
        .movement-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            z-index: 1000;
        }
        
        .movement-controls button {
            width: 60px;
            height: 60px;
            padding: 0;
            margin: 0;
            font-size: 24px;
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
        }
        
        .movement-controls button:active {
            background: rgba(76, 175, 80, 1);
            transform: scale(0.95);
        }
        
        .movement-controls button:disabled {
            background: rgba(85, 85, 85, 0.5);
            cursor: not-allowed;
        }
        
        .movement-controls .center-cell {
            grid-column: 2;
            grid-row: 2;
            background: rgba(33, 150, 243, 0.6);
        }
        
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .zoom-controls button {
            width: 50px;
            height: 50px;
            padding: 0;
            margin: 0;
            font-size: 20px;
            background: rgba(33, 150, 243, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
        }
        
        .zoom-controls button:active {
            background: rgba(33, 150, 243, 1);
            transform: scale(0.95);
        }
        
        .zoom-level {
            width: 50px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #fff;
        }
        
        .info-box {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .info-box h3 {
            margin-bottom: 10px;
            color: #4caf50;
        }
        
        .info-box p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .log {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .log-line {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-info { color: #4ec9b0; }
        .log-error { color: #f48771; }
        .log-warning { color: #dcdcaa; }
        
        /* Barcode Scanner Styles */
        #scanBtn {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 9999;
            padding: 12px 20px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        #scanBtn:hover {
            background: #45a049;
        }
        
        #scanUI {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9998;
        }
        
        #scanUI > div {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        #scanVideo {
            width: min(92vw, 520px);
            border-radius: 12px;
            background: #000;
        }
        
        #scanStatus {
            color: white;
            font: 14px system-ui;
            text-align: center;
        }
        
        #closeScan {
            padding: 10px 16px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
        }
        
        #closeScan:hover {
            background: #da190b;
        }
    </style>
</head>
<body>
    <!-- Barcode Scanner UI -->
    <button id="scanBtn">üì∑ Scan</button>
    
    <div id="scanUI">
        <div>
            <video id="scanVideo" playsinline muted></video>
            <div id="scanStatus">Requesting camera‚Ä¶</div>
            <button id="closeScan">Close</button>
        </div>
    </div>
    
    <div class="container">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- Movement Controls -->
            <div class="movement-controls">
                <button id="btnMoveNW" style="grid-column: 1; grid-row: 1;">‚Üñ</button>
                <button id="btnMoveN" style="grid-column: 2; grid-row: 1;">‚Üë</button>
                <button id="btnMoveNE" style="grid-column: 3; grid-row: 1;">‚Üó</button>
                <button id="btnMoveW" style="grid-column: 1; grid-row: 2;">‚Üê</button>
                <div class="center-cell"></div>
                <button id="btnMoveE" style="grid-column: 3; grid-row: 2;">‚Üí</button>
                <button id="btnMoveSW" style="grid-column: 1; grid-row: 3;">‚Üô</button>
                <button id="btnMoveS" style="grid-column: 2; grid-row: 3;">‚Üì</button>
                <button id="btnMoveSE" style="grid-column: 3; grid-row: 3;">‚Üò</button>
            </div>
            
            <!-- Zoom Controls (locked at 5x) -->
            <div class="zoom-controls">
                <div class="zoom-level" id="zoomLevel" style="margin-bottom: 10px;">5.0x</div>
                <button id="btnToggle3D" style="font-size: 14px; width: 50px; height: 30px;">3D</button>
            </div>
        </div>
        
        <div class="sidebar">
            <div id="status" class="status disconnected">
                <strong>Status:</strong> <span id="statusText">Disconnected</span>
            </div>
            
            <div class="controls">
                <input type="text" id="serverUrl" placeholder="Server URL" value="http://localhost:8080">
                <input type="text" id="playerId" placeholder="Player ID" value="12345">
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" class="disconnect" disabled>Disconnect</button>
            </div>
            
            <div class="info-box">
                <h3>Player Info</h3>
                <p>ID: <span id="myPlayerId">-</span></p>
                <p>Position: <span id="myPosition">0, 0</span></p>
                <p>Nearby Players: <span id="nearbyCount">0</span></p>
            </div>
            
            <div class="info-box">
                <h3>Controls</h3>
                <p>WASD or Arrow Keys: Move</p>
                <p>Mouse: Look around</p>
            </div>
            
            <div class="info-box">
                <h3>Log</h3>
                <div id="log" class="log"></div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================================================
        // WASM Module Loading
        // ============================================================================
        let Module = null;
        let wasmReady = false;
        
        // Load WASM module using dynamic import (ES6 module)
        async function loadWasmModule() {
            try {
                const module = await import('./epoll_server.js');
                const ModuleFactory = module.default || module;
                
                if (typeof ModuleFactory === 'function') {
                    Module = await ModuleFactory();
                    wasmReady = true;
                    console.log('WASM module loaded');
                    log('WASM module loaded successfully', 'info');
                    if (typeof onWasmReady === 'function') {
                        onWasmReady();
                    }
                } else {
                    Module = ModuleFactory;
                    wasmReady = true;
                    console.log('WASM module ready');
                    log('WASM module ready', 'info');
                    if (typeof onWasmReady === 'function') {
                        onWasmReady();
                    }
                }
            } catch (err) {
                console.error('Failed to load WASM module:', err);
                log(`WASM load error: ${err.message}`, 'error');
            }
        }
        
        // Start loading WASM module after page loads
        window.addEventListener('load', () => {
            loadWasmModule();
        });
        
        // ============================================================================
        // World Region Generator JavaScript Wrapper
        // ============================================================================
        class WorldRegionGenerator {
            constructor(seed = 422, radius = 10, seaLevel = 0.3) {
                this.seed = seed;
                this.radius = radius;
                this.seaLevel = seaLevel;
                this.initialized = false;
                this.currentRegion = null;
            }
            
            // Initialize the generator (must be called after WASM is ready)
            init() {
                if (!wasmReady || !Module) {
                    throw new Error('WASM module not ready');
                }
                
                // Convert seed to BigInt (WASM expects uint64_t)
                const seedBigInt = BigInt(this.seed);
                Module._init_region_generator(seedBigInt, this.radius, this.seaLevel);
                this.initialized = true;
            }
            
            // Generate a region at the given center coordinates
            generateRegion(centerX, centerY, radius = null) {
                if (!this.initialized) {
                    this.init();
                }
                
                const r = radius || this.radius;
                const regionPtr = Module._generate_region(centerX, centerY, r);
                
                if (!regionPtr) {
                    throw new Error('Failed to generate region');
                }
                
                this.currentRegion = {
                    ptr: regionPtr,
                    centerX: centerX,
                    centerY: centerY,
                    radius: r,
                    width: Module._get_region_width(regionPtr),
                    height: Module._get_region_height(regionPtr),
                    startX: Module._get_region_start_x(regionPtr),
                    startY: Module._get_region_start_y(regionPtr)
                };
                
                return this.currentRegion;
            }
            
            // Shift region in a direction (0=East, 1=West, 2=North, 3=South)
            shiftRegion(direction, tiles = 1) {
                if (!this.currentRegion) {
                    throw new Error('No region loaded. Call generateRegion first.');
                }
                
                const newTiles = Module._shift_region(this.currentRegion.ptr, direction, tiles);
                
                // Update region info
                this.currentRegion.width = Module._get_region_width(this.currentRegion.ptr);
                this.currentRegion.height = Module._get_region_height(this.currentRegion.ptr);
                this.currentRegion.startX = Module._get_region_start_x(this.currentRegion.ptr);
                this.currentRegion.startY = Module._get_region_start_y(this.currentRegion.ptr);
                this.currentRegion.centerX = Module._get_region_center_x(this.currentRegion.ptr);
                this.currentRegion.centerY = Module._get_region_center_y(this.currentRegion.ptr);
                
                return newTiles;
            }
            
            // Get terrain height at world coordinates
            getTerrainHeight(worldX, worldY) {
                if (!this.currentRegion) {
                    return 0;
                }
                
                const encoded = Module._get_terrain_cell_height(this.currentRegion.ptr, worldX, worldY);
                return encoded / 10000.0; // Decode from int
            }
            
            // Get biome type at world coordinates
            getBiomeType(worldX, worldY) {
                if (!this.currentRegion) {
                    return 0;
                }
                
                return Module._get_biome_cell_type(this.currentRegion.ptr, worldX, worldY);
            }
            
            // Render region using C++ isometric renderer (same as world.bmp output)
            // viewCenterX/Y: world coordinates to center view on (use -1 to center on region center)
            // zoom: zoom level (1.0 = normal, >1.0 = zoomed in, <1.0 = zoomed out)
            renderIsometric(outputWidth = null, outputHeight = null, viewCenterX = -1, viewCenterY = -1, zoom = 1.0, animationTime = 0.0) {
                if (!this.currentRegion) {
                    return null;
                }
                
                // Use canvas size if not specified
                const width = outputWidth || canvas.width;
                const height = outputHeight || canvas.height;
                
                const bufferPtr = Module._render_region_isometric(
                    this.currentRegion.ptr, 
                    width, 
                    height,
                    viewCenterX,
                    viewCenterY,
                    zoom,
                    animationTime
                );
                
                if (!bufferPtr) {
                    return null;
                }
                
                return {
                    ptr: bufferPtr,
                    width: Module._get_pixel_buffer_width(bufferPtr),
                    height: Module._get_pixel_buffer_height(bufferPtr)
                };
            }
            
            // Render region in 3D (isometric-style 3D view)
            render3D(outputWidth = null, outputHeight = null, viewCenterX = -1, viewCenterY = -1, zoom = 1.0) {
                if (!this.currentRegion) {
                    return null;
                }
                
                // Use canvas size if not specified
                const width = outputWidth || canvas.width;
                const height = outputHeight || canvas.height;
                
                const bufferPtr = Module._render_region_3d(
                    this.currentRegion.ptr, 
                    width, 
                    height,
                    viewCenterX,
                    viewCenterY,
                    zoom
                );
                
                if (!bufferPtr) {
                    return null;
                }
                
                return {
                    ptr: bufferPtr,
                    width: Module._get_pixel_buffer_width(bufferPtr),
                    height: Module._get_pixel_buffer_height(bufferPtr)
                };
            }
            
            // Free the current region
            free() {
                if (this.currentRegion) {
                    Module._free_region_data(this.currentRegion.ptr);
                    this.currentRegion = null;
                }
            }
        }
        
        // ============================================================================
        // Game state
        // ============================================================================
        let canvas, ctx;
        let myPlayerId = 12345;
        let myX = 5000;
        let myY = 5000;
        let lastSentX = null;
        let lastSentY = null;
        let lastSentFlags = null;
        let nearbyPlayers = [];
        let connected = false;
        let updateInterval = null;
        let serverUrl = 'http://localhost:8080';
        
        // Animation time tracking for water animation
        let animationStartTime = null;
        
        // World region generator (client-side)
        let worldGen = null;
        let currentRegionCenterX = 0;
        let currentRegionCenterY = 0;
        const REGION_RADIUS = 10; // tiles (minimal radius for 5x zoom - region size = 9x9)
        
        // World seed (from barcode scan)
        let worldSeed = 422; // Default seed
        
        // Zoom state - locked at 5x
        let zoomLevel = 5.0;
        const MIN_ZOOM = 5.0; // Locked
        const MAX_ZOOM = 5.0; // Locked
        const ZOOM_STEP = 0.25;
        
        // View mode (2D isometric or 3D)
        let viewMode3D = false;
        
        // Display position (snaps to target, no interpolation)
        let displayX = 5000.0;  // Display position for rendering
        let displayY = 5000.0;
        
        // Callback when WASM is ready
        function onWasmReady() {
            console.log('WASM ready, initializing world generator...');
            try {
                worldGen = new WorldRegionGenerator(worldSeed, REGION_RADIUS, 0.3);
                worldGen.init();
                log('World generator initialized', 'info');
                
                // Initialize display position to match target position
                displayX = Math.floor(myX);
                displayY = Math.floor(myY);
                
                // Generate initial region at player position
                const region = worldGen.generateRegion(
                    Math.floor(myX), 
                    Math.floor(myY), 
                    REGION_RADIUS
                );
                currentRegionCenterX = region.centerX;
                currentRegionCenterY = region.centerY;
                log(`Generated initial region at (${region.centerX}, ${region.centerY})`, 'info');
                draw(); // Redraw with terrain
            } catch (err) {
                log(`Failed to initialize world generator: ${err.message}`, 'error');
                console.error('World generator init error:', err);
            }
        }
        
        // Update region based on player position (client-side generation)
        function updateRegionForPosition() {
            if (!wasmReady || !worldGen) return;
            
            // Convert player position to tile coordinates
            const tileX = Math.floor(myX);
            const tileY = Math.floor(myY);
            
            // Calculate desired region center
            const desiredCenterX = tileX;
            const desiredCenterY = tileY;
            
            // Check if we need to shift the region
            if (!worldGen.currentRegion) {
                // Generate initial region
                try {
                    worldGen.generateRegion(desiredCenterX, desiredCenterY, REGION_RADIUS);
                    currentRegionCenterX = desiredCenterX;
                    currentRegionCenterY = desiredCenterY;
                    log(`Generated region at (${desiredCenterX}, ${desiredCenterY})`, 'info');
                } catch (err) {
                    log(`Failed to generate region: ${err.message}`, 'error');
                }
                return;
            }
            
            // Calculate distance from current region center
            const dx = desiredCenterX - currentRegionCenterX;
            const dy = desiredCenterY - currentRegionCenterY;
            
            // Shift region if player moved (threshold of 1 tile for smooth movement)
            const SHIFT_THRESHOLD = 1;
            if (Math.abs(dx) >= SHIFT_THRESHOLD || Math.abs(dy) >= SHIFT_THRESHOLD) {
                try {
                    // Shift region 1 tile at a time for smooth movement
                    // This prevents large jumps when player moves multiple tiles at once
                    let remainingDx = dx;
                    let remainingDy = dy;
                    
                    while (Math.abs(remainingDx) >= 1 || Math.abs(remainingDy) >= 1) {
                        let direction = 0;
                        let tiles = 1; // Always shift 1 tile at a time
                        
                        if (Math.abs(remainingDx) >= Math.abs(remainingDy)) {
                            // Horizontal movement
                            direction = remainingDx > 0 ? 0 : 1; // 0=East, 1=West
                            remainingDx -= remainingDx > 0 ? 1 : -1;
                        } else {
                            // Vertical movement
                            direction = remainingDy > 0 ? 3 : 2; // 3=South, 2=North
                            remainingDy -= remainingDy > 0 ? 1 : -1;
                        }
                        
                        // Shift region by 1 tile
                        worldGen.shiftRegion(direction, tiles);
                    }
                    
                    // Update region center after all shifts
                    currentRegionCenterX = worldGen.currentRegion.centerX;
                    currentRegionCenterY = worldGen.currentRegion.centerY;
                    
                    log(`Shifted region to (${currentRegionCenterX}, ${currentRegionCenterY})`, 'info');
                } catch (err) {
                    log(`Failed to shift region: ${err.message}`, 'error');
                    // Fallback: regenerate region
                    try {
                        worldGen.free();
                        worldGen.generateRegion(desiredCenterX, desiredCenterY, REGION_RADIUS);
                        currentRegionCenterX = desiredCenterX;
                        currentRegionCenterY = desiredCenterY;
                    } catch (err2) {
                        log(`Failed to regenerate region: ${err2.message}`, 'error');
                    }
                }
            }
        }
        
        // Initialize canvas
        function initCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                draw();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Mouse movement
            let mouseX = 0, mouseY = 0;
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });
            
            // Keyboard controls
            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                handleMovement();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            function handleMovement() {
                if (!connected) return;
                
                const speed = 1;
                let moved = false;
                
                if (keys['w'] || keys['arrowup']) {
                    myY -= speed;
                    moved = true;
                }
                if (keys['s'] || keys['arrowdown']) {
                    myY += speed;
                    moved = true;
                }
                if (keys['a'] || keys['arrowleft']) {
                    myX -= speed;
                    moved = true;
                }
                if (keys['d'] || keys['arrowright']) {
                    myX += speed;
                    moved = true;
                }
                
                if (moved) {
                    sendMoveUpdate();
                }
            }
            
            // Update display position (snap to tile, no interpolation)
            function updateDisplayPosition() {
                // Snap directly to the target tile position
                displayX = Math.floor(myX);
                displayY = Math.floor(myY);
            }
            
            // Continuous movement check
            setInterval(() => {
                if (connected) {
                    handleMovement();
                }
            }, 16); // ~60fps
            
            // Continuous rendering loop
            function renderLoop() {
                // Update display position every frame (snap to tile)
                updateDisplayPosition();
                draw();
                requestAnimationFrame(renderLoop);
            }
            renderLoop();
        }
        
        // Draw game
        function draw() {
            if (!ctx) return;
            
            // Initialize animation time on first frame
            if (animationStartTime === null) {
                animationStartTime = performance.now() / 1000.0; // Convert to seconds
            }
            
            // Calculate current animation time in seconds
            const currentTime = performance.now() / 1000.0;
            const animationTime = currentTime - animationStartTime;
            
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate camera offset (center player)
            const cameraX = myX - canvas.width / 2;
            const cameraY = myY - canvas.height / 2;
            
            // Draw terrain from generated region using C++ renderer (exact same as world.bmp)
            if (wasmReady && worldGen && worldGen.currentRegion) {
                // Render at full canvas size with zoom - C++ renderer handles zoom correctly
                // Center view on smooth display position (in world coordinates) for smooth movement
                const renderBuffer = viewMode3D 
                    ? worldGen.render3D(
                        canvas.width, 
                        canvas.height, 
                        Math.floor(displayX), 
                        Math.floor(displayY),
                        zoomLevel
                    )
                    : worldGen.renderIsometric(
                        canvas.width, 
                        canvas.height, 
                        Math.floor(displayX), 
                        Math.floor(displayY),
                        zoomLevel,
                        animationTime
                    );
                
                if (renderBuffer) {
                    // Create ImageData from pixel buffer
                    const imageData = ctx.createImageData(renderBuffer.width, renderBuffer.height);
                    
                    // OPTIMIZED: Direct memory access instead of per-pixel function calls
                    // This is 10-50x faster than the previous double loop
                    try {
                        const dataPtr = Module._get_pixel_buffer_data(renderBuffer.ptr);
                        const dataSize = Module._get_pixel_buffer_size_bytes(renderBuffer.ptr);
                        
                        if (dataPtr && dataSize > 0) {
                            // Try multiple methods to access WASM memory
                            let memoryBuffer = null;
                            
                            // Method 1: HEAPU8 (standard Emscripten)
                            if (Module.HEAPU8 && Module.HEAPU8.buffer) {
                                memoryBuffer = Module.HEAPU8.buffer;
                            }
                            // Method 2: HEAP8 (alternative)
                            else if (Module.HEAP8 && Module.HEAP8.buffer) {
                                memoryBuffer = Module.HEAP8.buffer;
                            }
                            // Method 3: Direct buffer access
                            else if (Module.buffer) {
                                memoryBuffer = Module.buffer;
                            }
                            // Method 4: WASM memory (newer Emscripten)
                            else if (Module.wasmMemory && Module.wasmMemory.buffer) {
                                memoryBuffer = Module.wasmMemory.buffer;
                            }
                            
                            if (memoryBuffer) {
                                // Create a view into WASM memory for direct access
                                const dataView = new Uint8ClampedArray(
                                    memoryBuffer, 
                                    dataPtr, 
                                    dataSize
                                );
                                
                                // Single bulk copy operation - MUCH faster!
                                imageData.data.set(dataView);
                            } else {
                                // Fall through to per-pixel method
                                throw new Error('No WASM memory access method available');
                            }
                        } else {
                            // Fallback to old method if optimized access not available
                            // (HEAPU8 might not be available or dataPtr/dataSize invalid)
                            for (let y = 0; y < renderBuffer.height; y++) {
                                for (let x = 0; x < renderBuffer.width; x++) {
                                    const rgba = Module._get_pixel(renderBuffer.ptr, x, y);
                                    const idx = (y * renderBuffer.width + x) * 4;
                                    imageData.data[idx] = (rgba >> 24) & 0xFF;
                                    imageData.data[idx + 1] = (rgba >> 16) & 0xFF;
                                    imageData.data[idx + 2] = (rgba >> 8) & 0xFF;
                                    imageData.data[idx + 3] = rgba & 0xFF;
                                }
                            }
                        }
                    } catch (e) {
                        // Fallback if optimized method fails
                        console.warn('Optimized pixel copy failed, using fallback:', e);
                        for (let y = 0; y < renderBuffer.height; y++) {
                            for (let x = 0; x < renderBuffer.width; x++) {
                                const rgba = Module._get_pixel(renderBuffer.ptr, x, y);
                                const idx = (y * renderBuffer.width + x) * 4;
                                imageData.data[idx] = (rgba >> 24) & 0xFF;
                                imageData.data[idx + 1] = (rgba >> 16) & 0xFF;
                                imageData.data[idx + 2] = (rgba >> 8) & 0xFF;
                                imageData.data[idx + 3] = rgba & 0xFF;
                            }
                        }
                    }
                    
                    // Draw terrain - offset to center player if they're at edge of region
                    // If player is at bottom corner, offset terrain so player appears at canvas center
                    let drawX = 0;
                    let drawY = 0;
                    
                    if (worldGen && worldGen.currentRegion && 
                        (renderBuffer.width !== canvas.width || renderBuffer.height !== canvas.height)) {
                        const playerLocalX = Math.floor(displayX) - worldGen.currentRegion.startX;
                        const playerLocalY = Math.floor(displayY) - worldGen.currentRegion.startY;
                        const regionWidth = worldGen.currentRegion.width;
                        const regionHeight = worldGen.currentRegion.height;
                        
                        // Calculate normalized position (0.0 = top-left, 1.0 = bottom-right)
                        const normX = playerLocalX / regionWidth;
                        const normY = playerLocalY / regionHeight;
                        
                        // Offset terrain so player appears at canvas center
                        // If player is at bottom-right (1.0, 1.0), offset by (canvas - buffer)
                        // If player is at top-left (0.0, 0.0), offset by 0
                        drawX = Math.round((canvas.width - renderBuffer.width) * normX);
                        drawY = Math.round((canvas.height - renderBuffer.height) * normY);
                    }
                    
                    ctx.putImageData(imageData, drawX, drawY);
                    
                    // Free the pixel buffer
                    Module._free_pixel_buffer(renderBuffer.ptr);
                }
            } else {
                // Fallback: Draw grid if no terrain
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                const gridSize = 100;
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Draw nearby players
            // Convert world coordinates to isometric screen coordinates
            // Isometric projection: sx = (wx - wy) * (tileWidth/2), sy = (wx + wy) * (tileHeight/2)
            // Match the isometric renderer's default tile dimensions
            const TILE_WIDTH = 64;  // Default isometric tile width
            const TILE_HEIGHT = 32; // Default isometric tile height
            
            // Use batch coordinate conversion for multiple players (optimization)
            if (nearbyPlayers.length > 5 && Module._convert_world_to_isometric) {
                try {
                    // Allocate memory for input and output arrays
                    const count = nearbyPlayers.length;
                    const worldXPtr = Module._malloc(count * 4); // int = 4 bytes
                    const worldYPtr = Module._malloc(count * 4);
                    const screenXPtr = Module._malloc(count * 4);
                    const screenYPtr = Module._malloc(count * 4);
                    
                    // Fill input arrays
                    const worldXView = new Int32Array(Module.HEAP32.buffer, worldXPtr, count);
                    const worldYView = new Int32Array(Module.HEAP32.buffer, worldYPtr, count);
                    nearbyPlayers.forEach((player, i) => {
                        worldXView[i] = player.x;
                        worldYView[i] = player.y;
                    });
                    
                    // Call batch conversion
                    Module._convert_world_to_isometric(
                        worldXPtr, worldYPtr, count,
                        Math.floor(displayX), Math.floor(displayY),
                        canvas.width / 2, canvas.height / 2,
                        TILE_WIDTH, TILE_HEIGHT,
                        screenXPtr, screenYPtr
                    );
                    
                    // Read results and apply zoom scaling
                    const screenXView = new Int32Array(Module.HEAP32.buffer, screenXPtr, count);
                    const screenYView = new Int32Array(Module.HEAP32.buffer, screenYPtr, count);
                    
                    nearbyPlayers.forEach((player, i) => {
                        // CRITICAL: Apply zoom scaling to match terrain rendering
                        // The base conversion gives us coordinates at zoom=1.0, so we scale by zoomLevel
                        const baseX = screenXView[i];
                        const baseY = screenYView[i];
                        const screenX = canvas.width / 2 + (baseX - canvas.width / 2) * zoomLevel;
                        const screenY = canvas.height / 2 + (baseY - canvas.height / 2) * zoomLevel;
                        
                        // Only draw if on screen
                        if (screenX >= -20 && screenX <= canvas.width + 20 &&
                            screenY >= -20 && screenY <= canvas.height + 20) {
                            
                            // Draw player circle
                            ctx.fillStyle = player.playerId === myPlayerId ? '#4caf50' : '#2196F3';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Draw player ID
                            ctx.fillStyle = '#fff';
                            ctx.font = '12px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(player.playerId.toString(), screenX, screenY - 25);
                        }
                    });
                    
                    // Free allocated memory
                    Module._free(worldXPtr);
                    Module._free(worldYPtr);
                    Module._free(screenXPtr);
                    Module._free(screenYPtr);
                } catch (e) {
                    // Fallback to per-player conversion if batch fails
                    console.warn('Batch coordinate conversion failed, using fallback:', e);
                    drawPlayersIndividually();
                }
            } else {
                // Use individual conversion (faster for small numbers of players)
                drawPlayersIndividually();
            }
            
            function drawPlayersIndividually() {
                nearbyPlayers.forEach(player => {
                    // Convert player world position to isometric screen coordinates
                    const playerWorldX = player.x;
                    const playerWorldY = player.y;
                    // Use smooth display position for centering
                    const myWorldX = displayX;
                    const myWorldY = displayY;
                    
                    // Calculate relative position from player to my position
                    const relX = playerWorldX - myWorldX;
                    const relY = playerWorldY - myWorldY;
                    
                    // Convert to isometric screen coordinates (relative to center)
                    // Use renderer tile dimensions to match terrain rendering
                    const RENDERER_TILE_WIDTH = 32;
                    const RENDERER_TILE_HEIGHT = 16;
                    const TILE_DEPTH = 8;
                    const MAX_STACK_HEIGHT = 16;
                    
                    const isoX = (relX - relY) * (RENDERER_TILE_WIDTH / 2) * zoomLevel;
                    const isoY = (relX + relY) * (RENDERER_TILE_HEIGHT / 2) * zoomLevel;
                    
                    // Get terrain height at other player's position to apply height offset
                    let heightOffset = 0;
                    if (worldGen && worldGen.currentRegion) {
                        const playerTileX = Math.floor(playerWorldX);
                        const playerTileY = Math.floor(playerWorldY);
                        const encodedHeight = Module._get_terrain_cell_height_animated(
                            worldGen.currentRegion.ptr,
                            playerTileX,
                            playerTileY,
                            animationTime,
                            1.0 // waterAnimationSpeed
                        );
                        if (encodedHeight > 0) {
                            const terrainHeight = encodedHeight / 10000.0;
                            const heightPx = terrainHeight * MAX_STACK_HEIGHT * TILE_DEPTH;
                            // Apply height offset (higher terrain appears higher on screen, smaller Y)
                            heightOffset = -heightPx * zoomLevel;
                        }
                    }
                    
                    // Center on screen (my player is at canvas center)
                    const screenX = canvas.width / 2 + isoX;
                    const screenY = canvas.height / 2 + isoY + heightOffset;
                    
                    // Only draw if on screen
                    if (screenX >= -20 && screenX <= canvas.width + 20 &&
                        screenY >= -20 && screenY <= canvas.height + 20) {
                        
                        // Draw player circle
                        ctx.fillStyle = player.playerId === myPlayerId ? '#4caf50' : '#2196F3';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw player ID
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(player.playerId.toString(), screenX, screenY - 25);
                    }
                });
            }
            
            // Draw my player (always visible, centered)
            // Position player to match tile anchor point (center of diamond)
            // Tiles use worldToScreen conversion and anchor at that position
            // Note: Actual tile size in renderer is 32x16, but TILE_WIDTH/HEIGHT are already defined above
            const TILE_DEPTH = 8;
            const MAX_STACK_HEIGHT = 16;
            // Use actual renderer tile dimensions (32x16) instead of the display constants (64x32)
            const RENDERER_TILE_WIDTH = 32;
            const RENDERER_TILE_HEIGHT = 16;
            
            let playerX = canvas.width / 2;
            let playerY = canvas.height / 2;
            
            if (wasmReady && worldGen && worldGen.currentRegion) {
                // Get the tile the player is on (for height lookup)
                const playerTileX = Math.floor(displayX);
                const playerTileY = Math.floor(displayY);
                
                // Use animated height function - this returns the animated height for water tiles
                // so the player automatically bobs with the waves
                const waterAnimationSpeed = 1.0; // Should match config
                const encodedHeight = Module._get_terrain_cell_height_animated(
                    worldGen.currentRegion.ptr, 
                    playerTileX, 
                    playerTileY,
                    animationTime,
                    waterAnimationSpeed
                );
                
                if (encodedHeight > 0) {
                    // Decode height (was multiplied by 10000)
                    // This height already includes water animation offset for water tiles
                    const terrainHeight = encodedHeight / 10000.0;
                    
                    // Calculate the player's position relative to the view center
                    // The terrain is rendered centered on Math.floor(displayX), Math.floor(displayY)
                    const viewCenterX = Math.floor(displayX);
                    const viewCenterY = Math.floor(displayY);
                    
                    // Player's offset from the view center (can be fractional)
                    const playerOffsetX = displayX - viewCenterX;
                    const playerOffsetY = displayY - viewCenterY;
                    
                    // Convert player offset to isometric screen coordinates
                    // This uses the same worldToScreen formula: sx = (wx - wy) * (tileWidth/2), sy = (wx + wy) * (tileHeight/2)
                    const isoX = (playerOffsetX - playerOffsetY) * (RENDERER_TILE_WIDTH / 2);
                    const isoY = (playerOffsetX + playerOffsetY) * (RENDERER_TILE_HEIGHT / 2);
                    
                    // Calculate height in pixels (same as tile rendering)
                    const heightPx = terrainHeight * MAX_STACK_HEIGHT * TILE_DEPTH;
                    
                    // Apply height offset (higher terrain appears higher on screen, smaller Y)
                    // This matches: sy -= heightPx in tile rendering
                    const finalIsoY = isoY - heightPx;
                    
                    // Player is at canvas center, add the isometric offset with zoom
                    playerX = canvas.width / 2 + isoX * zoomLevel;
                    playerY = canvas.height / 2 + finalIsoY * zoomLevel;
                }
            }
            
            ctx.fillStyle = '#4caf50';
            ctx.beginPath();
            ctx.arc(playerX, playerY, 20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('YOU', playerX, playerY - 30);
            
            // Draw coordinates and debug info
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`X: ${Math.floor(displayX)}, Y: ${Math.floor(displayY)}`, 10, 30);
            if (worldGen && worldGen.currentRegion) {
                ctx.fillText(`Region: (${worldGen.currentRegion.startX}, ${worldGen.currentRegion.startY}) size: ${worldGen.currentRegion.width}x${worldGen.currentRegion.height}`, 10, 45);
                ctx.fillText(`Player in region: (${Math.floor(displayX) - worldGen.currentRegion.startX}, ${Math.floor(displayY) - worldGen.currentRegion.startY})`, 10, 60);
            }
        }
        
        // Send move update to server with axis-aligned delta packing
        async function sendMoveUpdate() {
            // Update client-side region based on position
            updateRegionForPosition();
            
            if (!connected) return;
            
            try {
                // Determine which fields changed
                const xChanged = (lastSentX === null || lastSentX !== myX);
                const yChanged = (lastSentY === null || lastSentY !== myY);
                const flagsAndDelta = (0 << 12) | 16; // flags=0, delta=16ms
                const flagsChanged = (lastSentFlags === null || lastSentFlags !== flagsAndDelta);
                
                // Calculate field mask
                const MOVE_PACKET_HAS_X = 0x01;
                const MOVE_PACKET_HAS_Y = 0x02;
                const MOVE_PACKET_HAS_FLAGS = 0x04;
                const MOVE_PACKET_SINGLE = 0x80; // Single packet mode (no count byte)
                
                let fieldMask = MOVE_PACKET_SINGLE; // Set single packet bit
                if (xChanged) fieldMask |= MOVE_PACKET_HAS_X;
                if (yChanged) fieldMask |= MOVE_PACKET_HAS_Y;
                if (flagsChanged) fieldMask |= MOVE_PACKET_HAS_FLAGS;
                
                // Calculate packet size: playerId (2) + fieldMask (1) + optional fields
                // No count byte for single packets!
                let packetSize = 3; // base: playerId + fieldMask
                if (fieldMask & MOVE_PACKET_HAS_X) packetSize += 2;
                if (fieldMask & MOVE_PACKET_HAS_Y) packetSize += 2;
                if (fieldMask & MOVE_PACKET_HAS_FLAGS) packetSize += 2;
                
                // Create buffer with variable-length packet (no count byte for single packets)
                const buffer = new ArrayBuffer(packetSize);
                const view = new DataView(buffer);
                
                let offset = 0;
                
                // Write playerId
                view.setUint16(offset, myPlayerId, true); // little-endian
                offset += 2;
                
                // Write field mask
                view.setUint8(offset, fieldMask);
                offset += 1;
                
                // Write optional fields based on mask (snap to tile before sending)
                if (fieldMask & MOVE_PACKET_HAS_X) {
                    view.setUint16(offset, Math.floor(myX), true);
                    offset += 2;
                }
                if (fieldMask & MOVE_PACKET_HAS_Y) {
                    view.setUint16(offset, Math.floor(myY), true);
                    offset += 2;
                }
                if (fieldMask & MOVE_PACKET_HAS_FLAGS) {
                    view.setUint16(offset, flagsAndDelta, true);
                    offset += 2;
                }
                
                // Update last sent values
                if (xChanged) lastSentX = myX;
                if (yChanged) lastSentY = myY;
                if (flagsChanged) lastSentFlags = flagsAndDelta;
                
                const response = await fetch(`${serverUrl}/move_batch`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/octet-stream'
                    },
                    body: buffer
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const responseBuffer = await response.arrayBuffer();
                const responseView = new DataView(responseBuffer);
                
                // Parse response (first byte is count)
                const count = responseView.getUint8(0);
                nearbyPlayers = [];
                
                for (let i = 0; i < count; i++) {
                    const offset = 1 + i * 8;
                    nearbyPlayers.push({
                        playerId: responseView.getUint16(offset, true),
                        x: responseView.getUint16(offset + 2, true),
                        y: responseView.getUint16(offset + 4, true),
                        flagsAndDelta: responseView.getUint16(offset + 6, true)
                    });
                }
                
                // Update UI
                document.getElementById('myPosition').textContent = `${myX}, ${myY}`;
                document.getElementById('nearbyCount').textContent = nearbyPlayers.length;
                
                // Redraw
                draw();
                
            } catch (error) {
                log(`Error sending move: ${error.message}`, 'error');
            }
        }
        
        // Connect to server
        async function connect() {
            serverUrl = document.getElementById('serverUrl').value.trim();
            myPlayerId = parseInt(document.getElementById('playerId').value) || 12345;
            
            if (!serverUrl) {
                alert('Please enter a server URL');
                return;
            }
            
            try {
                log(`Connecting to ${serverUrl}...`, 'info');
                
                // Reset last sent values on connect to ensure full packet is sent
                lastSentX = null;
                lastSentY = null;
                lastSentFlags = null;
                
                // Test connection with a move update
                await sendMoveUpdate();
                
                connected = true;
                document.getElementById('status').className = 'status connected';
                document.getElementById('statusText').textContent = 'Connected';
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                document.getElementById('myPlayerId').textContent = myPlayerId;
                
                log('Connected successfully!', 'info');
                
                // Start periodic updates
                updateInterval = setInterval(() => {
                    sendMoveUpdate();
                }, 100); // Update every 100ms
                
            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                alert(`Failed to connect: ${error.message}\n\nMake sure the server is running on ${serverUrl}`);
            }
        }
        
        // Disconnect
        function disconnect() {
            connected = false;
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            
            document.getElementById('status').className = 'status disconnected';
            document.getElementById('statusText').textContent = 'Disconnected';
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            
            nearbyPlayers = [];
            draw();
            
            log('Disconnected', 'info');
        }
        
        // Logging
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;
            const time = new Date().toLocaleTimeString();
            line.textContent = `[${time}] ${message}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        // Barcode Scanner Implementation
        (() => {
            const scanBtn = document.getElementById("scanBtn");
            const scanUI = document.getElementById("scanUI");
            const closeScan = document.getElementById("closeScan");
            const video = document.getElementById("scanVideo");
            const statusEl = document.getElementById("scanStatus");

            let stream = null;
            let stopFlag = false;
            let currentDeviceId = null;

            function setStatus(msg) { 
                statusEl.textContent = msg; 
                log(`Scanner: ${msg}`, 'info');
            }

            function stopCamera() {
                stopFlag = true;
                if (stream) {
                    stream.getTracks().forEach(t => t.stop());
                    stream = null;
                }
                video.srcObject = null;
            }

            function emitResult(text) {
                // Convert barcode text to a seed (hash the string to uint64_t)
                // Use a simple hash function to convert string to number
                // This seed will be used for all terrain generation (noise, biomes, structures)
                function hashStringToSeed(str) {
                    let hash = 0n;
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5n) - hash) + BigInt(char);
                        // Mask to 64 bits to ensure consistent uint64_t conversion
                        hash = hash & 0xFFFFFFFFFFFFFFFFn;
                    }
                    // Ensure positive (uint64_t)
                    return hash < 0n ? -hash : hash;
                }
                
                const newSeed = hashStringToSeed(text);
                log(`Barcode scanned: "${text}" -> Seed: ${newSeed}`, 'info');
                
                // Update world seed - this will be used as the seed for terrain generation
                worldSeed = Number(newSeed);
                
                // Reinitialize world generator with new seed
                // This creates a new WorldRegionGenerator with the barcode-derived seed,
                // which will be used for all noise generation and terrain features
                if (wasmReady && worldGen) {
                    try {
                        worldGen.free(); // Free old region
                        worldGen = new WorldRegionGenerator(worldSeed, REGION_RADIUS, 0.3);
                        worldGen.init(); // Initialize WASM generator with the new seed
                        
                        // Generate new region at current position using the new seed
                        const region = worldGen.generateRegion(
                            Math.floor(myX),
                            Math.floor(myY),
                            REGION_RADIUS
                        );
                        currentRegionCenterX = region.centerX;
                        currentRegionCenterY = region.centerY;
                        log(`Generated new world with seed ${worldSeed} at (${region.centerX}, ${region.centerY})`, 'info');
                        draw();
                    } catch (err) {
                        log(`Failed to regenerate world with seed ${worldSeed}: ${err.message}`, 'error');
                    }
                }
                
                if (connected) {
                    // Send seed to server
                    sendSeedToServer(worldSeed);
                } else {
                    log('Not connected to server. Seed: ' + worldSeed, 'warning');
                }
            }

            async function sendSeedToServer(seed) {
                try {
                    // Send seed to server via /set_seed endpoint
                    const buffer = new ArrayBuffer(10); // 2 bytes playerId + 8 bytes seed (uint64_t)
                    const view = new DataView(buffer);
                    view.setUint16(0, myPlayerId, true); // little-endian
                    // JavaScript doesn't have native uint64_t, so we'll send as two uint32_t
                    // Convert BigInt seed to two uint32_t values
                    const seedBigInt = BigInt(seed);
                    const low32 = Number(seedBigInt & 0xFFFFFFFFn);
                    const high32 = Number((seedBigInt >> 32n) & 0xFFFFFFFFn);
                    view.setUint32(2, low32, true);
                    view.setUint32(6, high32, true);
                    
                    const response = await fetch(`${serverUrl}/set_seed`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/octet-stream'
                        },
                        body: buffer
                    });
                    
                    if (response.ok) {
                        log(`Seed sent to server: ${seed}`, 'info');
                    } else {
                        log(`Failed to send seed: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`Error sending seed: ${error.message}`, 'error');
                }
            }

            async function startCamera() {
                // Try to get the highest available resolution for better barcode detection
                // Start with more flexible constraints that will fall back gracefully
                // Based on best practices for barcode scanning: focusMode, aspectRatio, frameRate
                const constraints = {
                    audio: false,
                    video: {
                        facingMode: { ideal: "environment" },
                        width: { ideal: 1920, min: 640 }, // More flexible min resolution
                        height: { ideal: 1080, min: 480 },
                        frameRate: { ideal: 30, max: 60, min: 15 }, // Higher max for smoother scanning
                        aspectRatio: { ideal: 1.7777777778 }, // 16:9 aspect ratio for better quality
                        focusMode: { ideal: "continuous" }, // Try to enable autofocus in initial constraints
                        // Additional quality settings (may not be supported by all devices)
                        resizeMode: { ideal: "none" } // Don't resize, use native resolution
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // Get device ID for ZXing video device method
                const tracks = stream.getVideoTracks();
                if (tracks.length > 0) {
                    const track = tracks[0];
                    currentDeviceId = track.getSettings().deviceId;
                    const settings = track.getSettings();
                    log(`Camera device ID: ${currentDeviceId}`, 'info');
                    log(`Camera resolution: ${settings.width}x${settings.height} @ ${settings.frameRate}fps`, 'info');
                    
                    // Try to enable autofocus via applyConstraints
                    try {
                        const capabilities = track.getCapabilities();
                        log(`Camera capabilities: ${JSON.stringify(capabilities)}`, 'info');
                        
                        // Try to enable continuous autofocus - critical for barcode scanning
                        if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
                            try {
                                await track.applyConstraints({
                                    advanced: [{ focusMode: 'continuous' }]
                                });
                                log("Autofocus enabled: continuous", 'info');
                            } catch (e) {
                                // Some devices require focusMode in initial constraints, not advanced
                                log(`Could not set continuous focus via applyConstraints: ${e.message}`, 'warning');
                                // Try setting it in the initial constraints on next attempt
                            }
                        } else if (capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
                            try {
                                await track.applyConstraints({
                                    advanced: [{ focusMode: 'single-shot' }]
                                });
                                log("Autofocus enabled: single-shot", 'info');
                            } catch (e) {
                                log(`Could not set single-shot focus: ${e.message}`, 'warning');
                            }
                        } else {
                            log("Autofocus capability not available on this device", 'warning');
                        }
                        
                        // Try to set exposure mode for better image quality
                        if (capabilities.exposureMode && capabilities.exposureMode.includes('continuous')) {
                            try {
                                await track.applyConstraints({
                                    advanced: [{ exposureMode: 'continuous' }]
                                });
                                log("Auto exposure enabled: continuous", 'info');
                            } catch (e) {
                                // Exposure mode may not be settable
                            }
                        }
                        
                        // Try to set white balance for better color accuracy
                        if (capabilities.whiteBalanceMode && capabilities.whiteBalanceMode.includes('continuous')) {
                            try {
                                await track.applyConstraints({
                                    advanced: [{ whiteBalanceMode: 'continuous' }]
                                });
                                log("Auto white balance enabled: continuous", 'info');
                            } catch (e) {
                                // White balance may not be settable
                            }
                        }
                    } catch (e) {
                        log(`Could not set camera settings: ${e.message}`, 'warning');
                    }
                }
                
                // Wait for video to be ready with longer timeout for higher resolutions
                await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    const onLoadedMetadata = () => {
                        if (!resolved) {
                            resolved = true;
                            log(`Video metadata loaded: ${video.videoWidth}x${video.videoHeight}`, 'info');
                            resolve();
                        }
                    };
                    
                    const onError = (e) => {
                        if (!resolved) {
                            resolved = true;
                            log(`Video error: ${e.message}`, 'error');
                            reject(new Error("Video playback error"));
                        }
                    };
                    
                    // Check if already loaded
                    if (video.readyState >= 1) {
                        onLoadedMetadata();
                        return;
                    }
                    
                    video.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
                    video.addEventListener('error', onError, { once: true });
                    
                    // Longer timeout for higher resolutions (10 seconds)
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            // Check if video has dimensions even if metadata event didn't fire
                            if (video.videoWidth > 0 && video.videoHeight > 0) {
                                log(`Video metadata loaded (timeout check): ${video.videoWidth}x${video.videoHeight}`, 'info');
                                resolve();
                            } else {
                                reject(new Error("Video metadata timeout"));
                            }
                        }
                    }, 10000);
                });
                
                await video.play();
                log(`Video playing: readyState=${video.readyState}, paused=${video.paused}`, 'info');
            }

            function pickFormatsForDetector() {
                return [
                    "qr_code",
                    "ean_13",
                    "ean_8",
                    "upc_a",
                    "upc_e",
                    "code_128",
                    "code_39",
                    "codabar",
                    "itf",
                    "data_matrix",
                    "pdf417",
                    "aztec"
                ];
            }

            // Helper function to enhance image contrast and brightness for better scanning
            function enhanceImageForScanning(canvas, ctx) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply contrast and brightness adjustments
                const contrast = 1.2; // Increase contrast
                const brightness = 10; // Slight brightness boost
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply contrast
                    data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128 + brightness));     // R
                    data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128 + brightness)); // G
                    data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128 + brightness)); // B
                    // Alpha channel stays the same
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            async function scanWithBarcodeDetector() {
                // Check if BarcodeDetector is available
                if (!("BarcodeDetector" in window)) {
                    // Try to check if it's available but behind a flag
                    log("BarcodeDetector API not available in this browser", 'warning');
                    log("Note: BarcodeDetector may need to be enabled via chrome://flags/#enable-experimental-web-platform-features", 'info');
                    return false;
                }

                log("BarcodeDetector API found, checking support...", 'info');

                // Check if BarcodeDetector is actually supported
                let supportedFormats = [];
                try {
                    supportedFormats = await BarcodeDetector.getSupportedFormats();
                    log(`BarcodeDetector supported formats: ${supportedFormats.join(', ')}`, 'info');
                    if (supportedFormats.length === 0) {
                        log("BarcodeDetector reports no supported formats", 'warning');
                        return false;
                    }
                } catch (e) {
                    log(`BarcodeDetector.getSupportedFormats() failed: ${e.message}`, 'warning');
                    // Continue anyway - some browsers support it but not this method
                }

                let detector = null;
                try {
                    const requestedFormats = pickFormatsForDetector();
                    // Filter to only requested formats that are supported
                    const formatsToUse = supportedFormats.length > 0 
                        ? requestedFormats.filter(f => supportedFormats.includes(f))
                        : requestedFormats;
                    
                    if (formatsToUse.length > 0) {
                        detector = new BarcodeDetector({ formats: formatsToUse });
                        log(`BarcodeDetector created with formats: ${formatsToUse.join(', ')}`, 'info');
                    } else {
                        detector = new BarcodeDetector();
                        log("BarcodeDetector created without format filter (no matching formats)", 'info');
                    }
                } catch (e) {
                    log(`BarcodeDetector with formats failed: ${e.message}, trying without formats`, 'warning');
                    try { 
                        detector = new BarcodeDetector(); 
                        log("BarcodeDetector created without format filter", 'info');
                    } catch (e2) {
                        log(`BarcodeDetector creation failed: ${e2.message}`, 'error');
                        return false;
                    }
                }

                setStatus("Scanning (native)‚Ä¶");
                stopFlag = false;
                let frameCount = 0;
                const maxFrames = 300; // ~5 seconds at 60fps
                let lastError = null;
                let errorCount = 0;

                const loop = async () => {
                    if (stopFlag) {
                        log("BarcodeDetector stopped by user", 'info');
                        return false;
                    }
                    
                    if (frameCount++ > maxFrames) {
                        log(`BarcodeDetector timeout after ${maxFrames} frames, falling back to ZXing`, 'warning');
                        return false;
                    }
                    
                    try {
                        // Check if video is ready
                        if (video.readyState < 2) {
                            if (frameCount % 30 === 0) {
                                log(`Waiting for video (readyState: ${video.readyState})...`, 'info');
                            }
                            requestAnimationFrame(loop);
                            return true;
                        }
                        
                        // Detect barcodes from video
                        let codes = await detector.detect(video);
                        
                        // If no detection, try from canvas with enhanced image
                        if ((!codes || codes.length === 0) && frameCount % 10 === 0) {
                            try {
                                const canvas = document.createElement('canvas');
                                canvas.width = video.videoWidth || 640;
                                canvas.height = video.videoHeight || 480;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                
                                // Try enhanced version
                                enhanceImageForScanning(canvas, ctx);
                                codes = await detector.detect(canvas);
                                if (codes && codes.length > 0) {
                                    log("BarcodeDetector found barcode using enhanced canvas", 'info');
                                }
                            } catch (e) {
                                // Canvas detection failed, continue with video
                            }
                        }
                        
                        if (codes && codes.length > 0) {
                            const text = codes[0].rawValue || codes[0].rawValue || "";
                            if (text) {
                                log(`BarcodeDetector found: ${text} (format: ${codes[0].format || 'unknown'})`, 'info');
                                emitResult(text);
                                setStatus("Scanned!");
                                stopCamera();
                                scanUI.style.display = "none";
                                return false; // Stop looping
                            }
                        }
                        
                        // Reset error count on successful detection attempt
                        errorCount = 0;
                    } catch (e) {
                        errorCount++;
                        if (e.message !== lastError) {
                            log(`BarcodeDetector detect error (${errorCount}): ${e.message}`, errorCount > 5 ? 'error' : 'warning');
                            lastError = e.message;
                        }
                        
                        // If we get too many errors, fallback
                        if (errorCount > 10) {
                            log("BarcodeDetector too many errors, falling back to ZXing", 'error');
                            return false;
                        }
                    }
                    
                    requestAnimationFrame(loop);
                    return true;
                };

                const result = await loop();
                return result !== false; // Return true if still running, false if stopped/errored
            }

            async function ensureZXing() {
                if (window.ZXingBrowser && window.ZXingBrowser.BrowserMultiFormatReader) {
                    log("ZXing already loaded", 'info');
                    return;
                }
                
                setStatus("Loading scanner fallback‚Ä¶");
                log("Loading ZXing library from CDN...", 'info');
                
                // Try UMD build from unpkg (most reliable)
                return new Promise((resolve, reject) => {
                    // Remove any existing ZXing scripts first
                    const existing = document.querySelector('script[src*="zxing"]');
                    if (existing) {
                        existing.remove();
                    }
                    
                    const s = document.createElement("script");
                    s.src = "https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js";
                    s.crossOrigin = "anonymous";
                    
                    s.onload = () => {
                        log("ZXing script tag loaded, waiting for global...", 'info');
                        // Give it time to set up globals
                        let attempts = 0;
                        const checkInterval = setInterval(() => {
                            attempts++;
                            log(`Checking for ZXing global (attempt ${attempts})...`, 'info');
                            
                            // Check various possible global names
                            if (window.ZXing && window.ZXing.BrowserMultiFormatReader) {
                                window.ZXingBrowser = window.ZXing;
                                clearInterval(checkInterval);
                                log("ZXing loaded successfully (window.ZXing)", 'info');
                                resolve();
                            } else if (window.ZXingBrowser && window.ZXingBrowser.BrowserMultiFormatReader) {
                                clearInterval(checkInterval);
                                log("ZXing loaded successfully (window.ZXingBrowser)", 'info');
                                resolve();
                            } else if (attempts > 20) {
                                clearInterval(checkInterval);
                                // Log what we found
                                const allKeys = Object.keys(window);
                                const zxKeys = allKeys.filter(k => 
                                    k.toLowerCase().includes('zx') || 
                                    k.toLowerCase().includes('barcode') ||
                                    k.toLowerCase().includes('reader')
                                );
                                log(`ZXing not found after 20 attempts. Window keys with 'zx'/'barcode'/'reader': ${zxKeys.join(', ') || 'none'}`, 'error');
                                log(`Total window keys: ${allKeys.length}`, 'info');
                                reject(new Error("ZXing BrowserMultiFormatReader not found after load"));
                            }
                        }, 100);
                    };
                    
                    s.onerror = (e) => {
                        log(`Script onerror event: ${e.message || 'unknown error'}`, 'error');
                        log(`Script src was: ${s.src}`, 'error');
                        reject(new Error(`Failed to load ZXing: network error or CORS issue`));
                    };
                    
                    // Set timeout
                    setTimeout(() => {
                        if (!window.ZXingBrowser) {
                            reject(new Error("ZXing load timeout"));
                        }
                    }, 10000);
                    
                    log(`Loading ZXing from: ${s.src}`, 'info');
                    document.head.appendChild(s);
                });
            }

            // Helper function to enhance image contrast and brightness for better scanning
            function enhanceImageForScanning(canvas, ctx) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply contrast and brightness adjustments
                const contrast = 1.2; // Increase contrast
                const brightness = 10; // Slight brightness boost
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply contrast
                    data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128 + brightness));     // R
                    data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128 + brightness)); // G
                    data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128 + brightness)); // B
                    // Alpha channel stays the same
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Try scanning from a canvas frame with image enhancement
            async function tryScanFromCanvas(reader, video) {
                try {
                    // Create a canvas to capture video frame
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth || 640;
                    canvas.height = video.videoHeight || 480;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw video frame to canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Try original image first - use decodeFromImageElement if available
                    try {
                        let result = null;
                        if (reader.decodeFromImageElement && typeof reader.decodeFromImageElement === 'function') {
                            result = await reader.decodeFromImageElement(canvas);
                        } else if (reader.decodeFromImage && typeof reader.decodeFromImage === 'function') {
                            result = await reader.decodeFromImage(canvas);
                        } else if (reader.decode && typeof reader.decode === 'function') {
                            // Fallback: try decode method
                            result = await reader.decode(canvas);
                        }
                        if (result) {
                            return result;
                        }
                    } catch (e) {
                        // Not found, try enhanced version
                    }
                    
                    // Try enhanced image
                    enhanceImageForScanning(canvas, ctx);
                    try {
                        let result = null;
                        if (reader.decodeFromImageElement && typeof reader.decodeFromImageElement === 'function') {
                            result = await reader.decodeFromImageElement(canvas);
                        } else if (reader.decodeFromImage && typeof reader.decodeFromImage === 'function') {
                            result = await reader.decodeFromImage(canvas);
                        } else if (reader.decode && typeof reader.decode === 'function') {
                            result = await reader.decode(canvas);
                        }
                        if (result) {
                            log("Barcode detected using enhanced image", 'info');
                            return result;
                        }
                    } catch (e) {
                        // Still not found
                    }
                    
                    return null;
                } catch (e) {
                    return null;
                }
            }

            async function scanWithZXing() {
                try {
                    await ensureZXing();
                } catch (e) {
                    log(`Failed to load ZXing: ${e.message}`, 'error');
                    setStatus("Scanner library failed to load");
                    throw e;
                }
                
                if (!window.ZXingBrowser || !window.ZXingBrowser.BrowserMultiFormatReader) {
                    throw new Error("ZXing BrowserMultiFormatReader not available");
                }

                setStatus("Scanning (fallback)‚Ä¶");
                stopFlag = false;
                log("Starting ZXing scanner", 'info');

                // Check video is ready
                if (video.readyState < 2) {
                    log(`Video not ready (readyState: ${video.readyState}), waiting...`, 'warning');
                    await new Promise(resolve => {
                        video.addEventListener('loadeddata', resolve, { once: true });
                        setTimeout(resolve, 2000); // Max 2 second wait
                    });
                }

                if (video.readyState < 2) {
                    throw new Error("Video element not ready for scanning");
                }

                log(`Video ready (readyState: ${video.readyState}, videoWidth: ${video.videoWidth}, videoHeight: ${video.videoHeight})`, 'info');

                // Create reader with hints for better detection
                // Note: ZXing handles all image preprocessing internally (grayscale, contrast, etc.)
                // We just need to configure hints for better detection
                const hints = new Map();
                let reader;
                if (window.ZXingBrowser && window.ZXingBrowser.DecodeHintType) {
                    const DecodeHintType = window.ZXingBrowser.DecodeHintType;
                    
                    // Enable more aggressive scanning - critical for better detection
                    hints.set(DecodeHintType.TRY_HARDER, true);
                    
                    // Also try CHARACTER_SET hint for better text decoding
                    try {
                        if (DecodeHintType.CHARACTER_SET !== undefined) {
                            hints.set(DecodeHintType.CHARACTER_SET, 'UTF-8');
                        }
                    } catch (e) {
                        // Character set hint may not be available
                    }
                    
                    // Specify all supported barcode formats
                    hints.set(DecodeHintType.POSSIBLE_FORMATS, [
                        window.ZXingBrowser.BarcodeFormat.QR_CODE,
                        window.ZXingBrowser.BarcodeFormat.EAN_13,
                        window.ZXingBrowser.BarcodeFormat.EAN_8,
                        window.ZXingBrowser.BarcodeFormat.UPC_A,
                        window.ZXingBrowser.BarcodeFormat.UPC_E,
                        window.ZXingBrowser.BarcodeFormat.CODE_128,
                        window.ZXingBrowser.BarcodeFormat.CODE_39,
                        window.ZXingBrowser.BarcodeFormat.CODABAR,
                        window.ZXingBrowser.BarcodeFormat.ITF,
                        window.ZXingBrowser.BarcodeFormat.DATA_MATRIX,
                        window.ZXingBrowser.BarcodeFormat.PDF_417,
                        window.ZXingBrowser.BarcodeFormat.AZTEC
                    ]);
                    
                    // Additional hints that may help with detection
                    try {
                        // Try to set additional hints if available
                        if (DecodeHintType.ASSUME_GS1 !== undefined) {
                            hints.set(DecodeHintType.ASSUME_GS1, false);
                        }
                        if (DecodeHintType.RETURN_CODABAR_START_END !== undefined) {
                            hints.set(DecodeHintType.RETURN_CODABAR_START_END, false);
                        }
                        // Enable pure barcode mode for better detection of linear barcodes
                        if (DecodeHintType.PURE_BARCODE !== undefined) {
                            hints.set(DecodeHintType.PURE_BARCODE, false); // false = allow noise around barcode
                        }
                        // Allow inverted barcodes
                        if (DecodeHintType.ALSO_INVERTED !== undefined) {
                            hints.set(DecodeHintType.ALSO_INVERTED, true);
                        }
                    } catch (e) {
                        // Some hints may not be available in all versions
                    }
                    
                    try {
                        reader = new window.ZXingBrowser.BrowserMultiFormatReader(hints);
                        log("ZXing reader created with enhanced hints", 'info');
                    } catch (e) {
                        log(`Failed to create reader with hints: ${e.message}, using default`, 'warning');
                        reader = new window.ZXingBrowser.BrowserMultiFormatReader();
                    }
                } else {
                    reader = new window.ZXingBrowser.BrowserMultiFormatReader();
                    log("ZXing reader created (hints not available in this version)", 'info');
                }
                
                log(`ZXing reader created. Video element: visible=${video.offsetParent !== null}, playing=${!video.paused}, dimensions=${video.videoWidth}x${video.videoHeight}`, 'info');

                // Use decodeFromVideoDevice with proper callback pattern (not Promise-based)
                return new Promise((resolve, reject) => {
                    let scanTimeout = setTimeout(() => {
                        log("ZXing scan timeout after 30 seconds", 'warning');
                        try { 
                            reader.reset(); 
                            log("ZXing reader reset", 'info');
                        } catch (e) {
                            log(`Error resetting ZXing: ${e.message}`, 'warning');
                        }
                        reject(new Error("Scan timeout - no barcode detected"));
                    }, 30000);

                    let callbackCount = 0;
                    let lastLogTime = Date.now();
                    let lastCanvasScanTime = 0;
                    const canvasScanInterval = 500; // Try canvas scanning every 500ms as backup

                    // Helper to extract text from result
                    function extractTextFromResult(result) {
                        let text = null;
                        let format = null;
                        let formatName = 'unknown';
                        
                        if (typeof result.getText === 'function') {
                            text = result.getText();
                            if (typeof result.getBarcodeFormat === 'function') {
                                format = result.getBarcodeFormat();
                                formatName = format.toString();
                                if (window.ZXingBrowser && window.ZXingBrowser.BarcodeFormat) {
                                    const formatNames = Object.keys(window.ZXingBrowser.BarcodeFormat);
                                    for (const name of formatNames) {
                                        if (window.ZXingBrowser.BarcodeFormat[name] === format) {
                                            formatName = name;
                                            break;
                                        }
                                    }
                                }
                            }
                        } else if (result.text) {
                            text = result.text;
                            format = result.format || result.barcodeFormat || null;
                            formatName = format ? String(format) : 'unknown';
                        } else {
                            text = String(result);
                        }
                        
                        return { text, format, formatName };
                    }

                    // Helper to handle successful scan
                    function handleScanSuccess(result) {
                        const { text, format, formatName } = extractTextFromResult(result);
                        
                        if (text && text.length > 0 && text !== '[object Object]' && text !== '[object Promise]') {
                            log(`‚úÖ ZXing detected barcode: "${text}" (format: ${formatName})`, 'info');
                            clearTimeout(scanTimeout);
                            emitResult(text);
                            setStatus("Scanned!");
                            stopCamera();
                            scanUI.style.display = "none";
                            resolve(true);
                            return true;
                        }
                        return false;
                    }

                    log("Starting ZXing decodeFromVideoDevice...", 'info');
                    
                    // decodeFromVideoDevice uses callback pattern, not Promise
                    // It returns controls object that can be used to stop scanning
                    const controls = reader.decodeFromVideoDevice(
                        currentDeviceId || null,  // device ID or null for default
                        video,                     // video element directly
                        async (result, error) => {      // callback: (result, error)
                            callbackCount++;
                            
                            // Log progress periodically
                            const now = Date.now();
                            if (now - lastLogTime > 2000) {
                                log(`Scanning... (callbacks: ${callbackCount}, hold barcode steady)`, 'info');
                                lastLogTime = now;
                            }
                            
                            if (stopFlag) {
                                log("ZXing stopped by user", 'info');
                                clearTimeout(scanTimeout);
                                try { 
                                    if (controls && controls.stop) {
                                        controls.stop();
                                    } else {
                                        reader.reset();
                                    }
                                } catch (e) {}
                                resolve(true);
                                return;
                            }
                            
                            // Try canvas-based scanning as backup every interval
                            if (now - lastCanvasScanTime > canvasScanInterval && video.readyState >= 2) {
                                lastCanvasScanTime = now;
                                try {
                                    const canvasResult = await tryScanFromCanvas(reader, video);
                                    if (canvasResult) {
                                        if (handleScanSuccess(canvasResult)) {
                                            try {
                                                if (controls && controls.stop) {
                                                    controls.stop();
                                                } else {
                                                    reader.reset();
                                                }
                                            } catch (e) {}
                                            return;
                                        }
                                    }
                                } catch (e) {
                                    // Canvas scan failed, continue with video
                                }
                            }
                            
                            if (error) {
                                // NotFoundException is normal - means no barcode found yet
                                // Only log unexpected errors
                                if (error.name !== 'NotFoundException' && 
                                    !error.message.includes('No MultiFormat Readers') &&
                                    !error.message.includes('NotFoundException')) {
                                    if (callbackCount <= 5) {
                                        log(`ZXing decode error: ${error.name} - ${error.message}`, 'warning');
                                    }
                                }
                                return; // Continue scanning
                            }
                            
                            if (result) {
                                if (handleScanSuccess(result)) {
                                    // Stop scanning
                                    try {
                                        if (controls && controls.stop) {
                                            controls.stop();
                                        } else {
                                            reader.reset();
                                        }
                                    } catch (e) {
                                        log(`Error stopping scanner: ${e.message}`, 'warning');
                                    }
                                    return;
                                }
                            }
                        }
                    );
                    
                    // Store controls for cleanup
                    if (controls) {
                        // Handle cleanup on timeout
                        scanTimeout = setTimeout(() => {
                            try {
                                if (controls.stop) {
                                    controls.stop();
                                } else {
                                    reader.reset();
                                }
                            } catch (e) {}
                            reject(new Error("Scan timeout - no barcode detected"));
                        }, 30000);
                    }
                    
                    log("ZXing decodeFromVideoDevice started", 'info');
                });
            }

            async function openScanner() {
                scanUI.style.display = "block";
                setStatus("Requesting camera‚Ä¶");
                stopFlag = false;

                try {
                    await startCamera();
                } catch (e) {
                    console.error(e);
                    setStatus("Camera permission denied or unavailable.");
                    log(`Camera error: ${e.message}`, 'error');
                    return;
                }

                // Prefer native, fallback to ZXing
                log("Attempting native BarcodeDetector...", 'info');
                const nativeOk = await scanWithBarcodeDetector();
                
                if (nativeOk === false || nativeOk === undefined) {
                    log("BarcodeDetector failed or unavailable, trying ZXing fallback...", 'info');
                    try {
                        await scanWithZXing();
                    } catch (e) {
                        console.error(e);
                        setStatus(`Scanner error: ${e.message}`);
                        log(`Scanner error: ${e.message}`, 'error');
                    }
                } else {
                    log("BarcodeDetector scanning in progress...", 'info');
                }
            }

            scanBtn.addEventListener("click", openScanner);
            closeScan.addEventListener("click", () => {
                stopCamera();
                scanUI.style.display = "none";
            });
        })();

        // Initialize
        window.addEventListener('load', () => {
            initCanvas();
            
            // Initialize movement controls
            function initMovementControls() {
                const directions = {
                    'btnMoveN': { dx: 0, dy: -1 },
                    'btnMoveS': { dx: 0, dy: 1 },
                    'btnMoveE': { dx: 1, dy: 0 },
                    'btnMoveW': { dx: -1, dy: 0 },
                    'btnMoveNE': { dx: 1, dy: -1 },
                    'btnMoveNW': { dx: -1, dy: -1 },
                    'btnMoveSE': { dx: 1, dy: 1 },
                    'btnMoveSW': { dx: -1, dy: 1 }
                };
                
                let movementKeys = {};
                
                Object.keys(directions).forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (!btn) return;
                    
                    const dir = directions[btnId];
                    
                    // Mouse/touch events
                    btn.addEventListener('mousedown', () => {
                        movementKeys[btnId] = true;
                    });
                    
                    btn.addEventListener('mouseup', () => {
                        movementKeys[btnId] = false;
                    });
                    
                    btn.addEventListener('mouseleave', () => {
                        movementKeys[btnId] = false;
                    });
                    
                    // Touch events for mobile
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        movementKeys[btnId] = true;
                    });
                    
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        movementKeys[btnId] = false;
                    });
                });
                
                // Movement handler
                function handleButtonMovement() {
                    let dx = 0, dy = 0;
                    
                    Object.keys(directions).forEach(btnId => {
                        if (movementKeys[btnId]) {
                            dx += directions[btnId].dx;
                            dy += directions[btnId].dy;
                        }
                    });
                    
                    if (dx !== 0 || dy !== 0) {
                        myX += dx;
                        myY += dy;
                        updateRegionForPosition();
                        if (connected) {
                            sendMoveUpdate();
                        }
                    }
                }
                
                // Update movement at 60fps
                setInterval(handleButtonMovement, 16);
            }
            
            // Initialize zoom controls (zoom is locked at 5x)
            function initZoomControls() {
                const zoomInBtn = document.getElementById('btnZoomIn');
                const zoomOutBtn = document.getElementById('btnZoomOut');
                const toggle3DBtn = document.getElementById('btnToggle3D');
                const zoomLevelDisplay = document.getElementById('zoomLevel');
                
                function updateZoomDisplay() {
                    if (zoomLevelDisplay) {
                        zoomLevelDisplay.textContent = zoomLevel.toFixed(1) + 'x';
                    }
                }
                
                // Zoom is locked, but keep functions for compatibility
                function zoomIn() {
                    // Zoom locked at 5x - do nothing
                }
                
                function zoomOut() {
                    // Zoom locked at 5x - do nothing
                }
                
                // Only add event listeners if buttons exist (they're removed when zoom is locked)
                if (zoomInBtn) {
                    zoomInBtn.addEventListener('click', zoomIn);
                }
                if (zoomOutBtn) {
                    zoomOutBtn.addEventListener('click', zoomOut);
                }
                
                // Toggle 3D view
                if (toggle3DBtn) {
                    toggle3DBtn.addEventListener('click', () => {
                        viewMode3D = !viewMode3D;
                        toggle3DBtn.textContent = viewMode3D ? '2D' : '3D';
                        toggle3DBtn.style.background = viewMode3D 
                            ? 'rgba(255, 152, 0, 0.8)' 
                            : 'rgba(33, 150, 243, 0.8)';
                        log(`Switched to ${viewMode3D ? '3D' : '2D'} view`, 'info');
                        draw(); // Force redraw when view mode changes
                    });
                }
                
                // Mouse wheel zoom (disabled - zoom locked at 5x)
                // canvas.addEventListener('wheel', (e) => {
                //     e.preventDefault();
                //     if (e.deltaY < 0) {
                //         zoomIn();
                //     } else {
                //         zoomOut();
                //     }
                // });
                
                // Touch pinch zoom (basic implementation)
                let lastTouchDistance = 0;
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        lastTouchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (lastTouchDistance > 0) {
                            const delta = (currentDistance - lastTouchDistance) / 100;
                            if (delta > 0.1) {
                                zoomIn();
                            } else if (delta < -0.1) {
                                zoomOut();
                            }
                        }
                        lastTouchDistance = currentDistance;
                    }
                });
                
                updateZoomDisplay();
            }
            
            initMovementControls();
            initZoomControls();
            log('Game client ready. Enter server URL and click Connect.', 'info');
            log('Loading WASM module for client-side world generation...', 'info');
            
            // Set up button event listeners
            document.getElementById('connectBtn').addEventListener('click', connect);
            document.getElementById('disconnectBtn').addEventListener('click', disconnect);
        });
    </script>
</body>
</html>